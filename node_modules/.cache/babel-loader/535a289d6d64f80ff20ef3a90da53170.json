{"ast":null,"code":"import _objectWithoutProperties from \"C:\\\\Users\\\\jewel\\\\Desktop\\\\Project\\\\React\\\\todo_app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\nimport _toConsumableArray from \"C:\\\\Users\\\\jewel\\\\Desktop\\\\Project\\\\React\\\\todo_app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/toConsumableArray\";\nimport _defineProperty from \"C:\\\\Users\\\\jewel\\\\Desktop\\\\Project\\\\React\\\\todo_app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"C:\\\\Users\\\\jewel\\\\Desktop\\\\Project\\\\React\\\\todo_app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\jewel\\\\Desktop\\\\Project\\\\React\\\\todo_app\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == typeof value && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator.return && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, catch: function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getLengthFromAxis(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'x' : 'y';\n}\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  var reference = _ref.reference,\n    floating = _ref.floating;\n  var commonX = reference.x + reference.width / 2 - floating.width / 2;\n  var commonY = reference.y + reference.height / 2 - floating.height / 2;\n  var mainAxis = getMainAxisFromPlacement(placement);\n  var length = getLengthFromAxis(mainAxis);\n  var commonAlign = reference[length] / 2 - floating[length] / 2;\n  var side = getSide(placement);\n  var isVertical = mainAxis === 'x';\n  var coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nvar computePosition = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(reference, floating, config) {\n    var _config$placement, placement, _config$strategy, strategy, _config$middleware, middleware, platform, validMiddleware, rtl, rects, _computeCoordsFromPla, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware$i, name, fn, _yield$fn, nextX, nextY, data, reset, _computeCoordsFromPla2;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _config$placement = config.placement, placement = _config$placement === void 0 ? 'bottom' : _config$placement, _config$strategy = config.strategy, strategy = _config$strategy === void 0 ? 'absolute' : _config$strategy, _config$middleware = config.middleware, middleware = _config$middleware === void 0 ? [] : _config$middleware, platform = config.platform;\n          validMiddleware = middleware.filter(Boolean);\n          _context.next = 4;\n          return platform.isRTL == null ? void 0 : platform.isRTL(floating);\n        case 4:\n          rtl = _context.sent;\n          if (!(process.env.NODE_ENV !== \"production\")) {\n            _context.next = 10;\n            break;\n          }\n          if (platform == null) {\n            console.error(['Floating UI: `platform` property was not passed to config. If you', 'want to use Floating UI on the web, install @floating-ui/dom', 'instead of the /core package. Otherwise, you can create your own', '`platform`: https://floating-ui.com/docs/platform'].join(' '));\n          }\n          if (!(validMiddleware.filter(function (_ref) {\n            var name = _ref.name;\n            return name === 'autoPlacement' || name === 'flip';\n          }).length > 1)) {\n            _context.next = 9;\n            break;\n          }\n          throw new Error(['Floating UI: duplicate `flip` and/or `autoPlacement` middleware', 'detected. This will lead to an infinite loop. Ensure only one of', 'either has been passed to the `middleware` array.'].join(' '));\n        case 9:\n          if (!reference || !floating) {\n            console.error(['Floating UI: The reference and/or floating element was not defined', 'when `computePosition()` was called. Ensure that both elements have', 'been created and can be measured.'].join(' '));\n          }\n        case 10:\n          _context.next = 12;\n          return platform.getElementRects({\n            reference: reference,\n            floating: floating,\n            strategy: strategy\n          });\n        case 12:\n          rects = _context.sent;\n          _computeCoordsFromPla = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPla.x, y = _computeCoordsFromPla.y;\n          statefulPlacement = placement;\n          middlewareData = {};\n          resetCount = 0;\n          i = 0;\n        case 18:\n          if (!(i < validMiddleware.length)) {\n            _context.next = 52;\n            break;\n          }\n          _validMiddleware$i = validMiddleware[i], name = _validMiddleware$i.name, fn = _validMiddleware$i.fn;\n          _context.next = 22;\n          return fn({\n            x: x,\n            y: y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy: strategy,\n            middlewareData: middlewareData,\n            rects: rects,\n            platform: platform,\n            elements: {\n              reference: reference,\n              floating: floating\n            }\n          });\n        case 22:\n          _yield$fn = _context.sent;\n          nextX = _yield$fn.x;\n          nextY = _yield$fn.y;\n          data = _yield$fn.data;\n          reset = _yield$fn.reset;\n          x = nextX != null ? nextX : x;\n          y = nextY != null ? nextY : y;\n          middlewareData = _objectSpread({}, middlewareData, _defineProperty({}, name, _objectSpread({}, middlewareData[name], data)));\n          if (process.env.NODE_ENV !== \"production\") {\n            if (resetCount > 50) {\n              console.warn(['Floating UI: The middleware lifecycle appears to be running in an', 'infinite loop. This is usually caused by a `reset` continually', 'being returned without a break condition.'].join(' '));\n            }\n          }\n          if (!(reset && resetCount <= 50)) {\n            _context.next = 49;\n            break;\n          }\n          resetCount++;\n          if (!(typeof reset === 'object')) {\n            _context.next = 47;\n            break;\n          }\n          if (reset.placement) {\n            statefulPlacement = reset.placement;\n          }\n          if (!reset.rects) {\n            _context.next = 44;\n            break;\n          }\n          if (!(reset.rects === true)) {\n            _context.next = 42;\n            break;\n          }\n          _context.next = 39;\n          return platform.getElementRects({\n            reference: reference,\n            floating: floating,\n            strategy: strategy\n          });\n        case 39:\n          _context.t0 = _context.sent;\n          _context.next = 43;\n          break;\n        case 42:\n          _context.t0 = reset.rects;\n        case 43:\n          rects = _context.t0;\n        case 44:\n          _computeCoordsFromPla2 = computeCoordsFromPlacement(rects, statefulPlacement, rtl);\n          x = _computeCoordsFromPla2.x;\n          y = _computeCoordsFromPla2.y;\n        case 47:\n          i = -1;\n          return _context.abrupt(\"continue\", 49);\n        case 49:\n          i++;\n          _context.next = 18;\n          break;\n        case 52:\n          return _context.abrupt(\"return\", {\n            x: x,\n            y: y,\n            placement: statefulPlacement,\n            strategy: strategy,\n            middlewareData: middlewareData\n          });\n        case 53:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function computePosition(_x, _x2, _x3) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nfunction expandPaddingObject(padding) {\n  return _objectSpread({\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  }, padding);\n}\nfunction getSideObjectFromPadding(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return _objectSpread({}, rect, {\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nfunction detectOverflow(_x4, _x5) {\n  return _detectOverflow.apply(this, arguments);\n}\nfunction _detectOverflow() {\n  _detectOverflow = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(middlewareArguments, options) {\n    var _await$platform$isEle, x, y, platform, rects, elements, strategy, _options8, _options8$boundary, boundary, _options8$rootBoundar, rootBoundary, _options8$elementCont, elementContext, _options8$altBoundary, altBoundary, _options8$padding, padding, paddingObject, altContext, element, clippingClientRect, rect, offsetParent, offsetScale, elementClientRect;\n    return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n      while (1) switch (_context10.prev = _context10.next) {\n        case 0:\n          if (options === void 0) {\n            options = {};\n          }\n          x = middlewareArguments.x, y = middlewareArguments.y, platform = middlewareArguments.platform, rects = middlewareArguments.rects, elements = middlewareArguments.elements, strategy = middlewareArguments.strategy;\n          _options8 = options, _options8$boundary = _options8.boundary, boundary = _options8$boundary === void 0 ? 'clippingAncestors' : _options8$boundary, _options8$rootBoundar = _options8.rootBoundary, rootBoundary = _options8$rootBoundar === void 0 ? 'viewport' : _options8$rootBoundar, _options8$elementCont = _options8.elementContext, elementContext = _options8$elementCont === void 0 ? 'floating' : _options8$elementCont, _options8$altBoundary = _options8.altBoundary, altBoundary = _options8$altBoundary === void 0 ? false : _options8$altBoundary, _options8$padding = _options8.padding, padding = _options8$padding === void 0 ? 0 : _options8$padding;\n          paddingObject = getSideObjectFromPadding(padding);\n          altContext = elementContext === 'floating' ? 'reference' : 'floating';\n          element = elements[altBoundary ? altContext : elementContext];\n          _context10.t0 = rectToClientRect;\n          _context10.t1 = platform;\n          _context10.next = 10;\n          return platform.isElement == null ? void 0 : platform.isElement(element);\n        case 10:\n          _context10.t2 = _await$platform$isEle = _context10.sent;\n          if (!(_context10.t2 != null)) {\n            _context10.next = 15;\n            break;\n          }\n          _context10.t3 = _await$platform$isEle;\n          _context10.next = 16;\n          break;\n        case 15:\n          _context10.t3 = true;\n        case 16:\n          if (!_context10.t3) {\n            _context10.next = 20;\n            break;\n          }\n          _context10.t4 = element;\n          _context10.next = 26;\n          break;\n        case 20:\n          _context10.t5 = element.contextElement;\n          if (_context10.t5) {\n            _context10.next = 25;\n            break;\n          }\n          _context10.next = 24;\n          return platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating);\n        case 24:\n          _context10.t5 = _context10.sent;\n        case 25:\n          _context10.t4 = _context10.t5;\n        case 26:\n          _context10.t6 = _context10.t4;\n          _context10.t7 = boundary;\n          _context10.t8 = rootBoundary;\n          _context10.t9 = strategy;\n          _context10.t10 = {\n            element: _context10.t6,\n            boundary: _context10.t7,\n            rootBoundary: _context10.t8,\n            strategy: _context10.t9\n          };\n          _context10.next = 33;\n          return _context10.t1.getClippingRect.call(_context10.t1, _context10.t10);\n        case 33:\n          _context10.t11 = _context10.sent;\n          clippingClientRect = (0, _context10.t0)(_context10.t11);\n          rect = elementContext === 'floating' ? _objectSpread({}, rects.floating, {\n            x: x,\n            y: y\n          }) : rects.reference;\n          _context10.next = 38;\n          return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating);\n        case 38:\n          offsetParent = _context10.sent;\n          _context10.next = 41;\n          return platform.isElement == null ? void 0 : platform.isElement(offsetParent);\n        case 41:\n          if (!_context10.sent) {\n            _context10.next = 50;\n            break;\n          }\n          _context10.next = 44;\n          return platform.getScale == null ? void 0 : platform.getScale(offsetParent);\n        case 44:\n          _context10.t13 = _context10.sent;\n          if (_context10.t13) {\n            _context10.next = 47;\n            break;\n          }\n          _context10.t13 = {\n            x: 1,\n            y: 1\n          };\n        case 47:\n          _context10.t12 = _context10.t13;\n          _context10.next = 51;\n          break;\n        case 50:\n          _context10.t12 = {\n            x: 1,\n            y: 1\n          };\n        case 51:\n          offsetScale = _context10.t12;\n          _context10.t14 = rectToClientRect;\n          if (!platform.convertOffsetParentRelativeRectToViewportRelativeRect) {\n            _context10.next = 59;\n            break;\n          }\n          _context10.next = 56;\n          return platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n            rect: rect,\n            offsetParent: offsetParent,\n            strategy: strategy\n          });\n        case 56:\n          _context10.t15 = _context10.sent;\n          _context10.next = 60;\n          break;\n        case 59:\n          _context10.t15 = rect;\n        case 60:\n          _context10.t16 = _context10.t15;\n          elementClientRect = (0, _context10.t14)(_context10.t16);\n          if (process.env.NODE_ENV !== \"production\") ;\n          return _context10.abrupt(\"return\", {\n            top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n            bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n            left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n            right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n          });\n        case 64:\n        case \"end\":\n          return _context10.stop();\n      }\n    }, _callee10);\n  }));\n  return _detectOverflow.apply(this, arguments);\n}\nvar min = Math.min;\nvar max = Math.max;\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\n\n/**\n * Positions an inner element of the floating element such that it is centered\n * to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nvar arrow = function arrow(options) {\n  return {\n    name: 'arrow',\n    options: options,\n    fn: function () {\n      var _fn = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(middlewareArguments) {\n        var _data, _ref4;\n        var _ref3, element, _ref3$padding, padding, x, y, placement, rects, platform, paddingObject, coords, axis, length, arrowDimensions, minProp, maxProp, endDiff, startDiff, arrowOffsetParent, clientSize, centerToReference, min, max, center, offset, shouldAddOffset, alignmentOffset;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              // Since `element` is required, we don't Partial<> the type.\n              _ref3 = options || {}, element = _ref3.element, _ref3$padding = _ref3.padding, padding = _ref3$padding === void 0 ? 0 : _ref3$padding;\n              x = middlewareArguments.x, y = middlewareArguments.y, placement = middlewareArguments.placement, rects = middlewareArguments.rects, platform = middlewareArguments.platform;\n              if (!(element == null)) {\n                _context2.next = 5;\n                break;\n              }\n              if (process.env.NODE_ENV !== \"production\") {\n                console.warn('Floating UI: No `element` was passed to the `arrow` middleware.');\n              }\n              return _context2.abrupt(\"return\", {});\n            case 5:\n              paddingObject = getSideObjectFromPadding(padding);\n              coords = {\n                x: x,\n                y: y\n              };\n              axis = getMainAxisFromPlacement(placement);\n              length = getLengthFromAxis(axis);\n              _context2.next = 11;\n              return platform.getDimensions(element);\n            case 11:\n              arrowDimensions = _context2.sent;\n              minProp = axis === 'y' ? 'top' : 'left';\n              maxProp = axis === 'y' ? 'bottom' : 'right';\n              endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n              startDiff = coords[axis] - rects.reference[axis];\n              _context2.next = 18;\n              return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element);\n            case 18:\n              arrowOffsetParent = _context2.sent;\n              clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n              if (clientSize === 0) {\n                clientSize = rects.floating[length];\n              }\n              centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the floating element if the center\n              // point is outside the floating element's bounds.\n              min = paddingObject[minProp];\n              max = clientSize - arrowDimensions[length] - paddingObject[maxProp];\n              center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n              offset = within(min, center, max); // If the reference is small enough that the arrow's padding causes it to\n              // to point to nothing for an aligned placement, adjust the offset of the\n              // floating element itself. This stops `shift()` from taking action, but can\n              // be worked around by calling it again after the `arrow()` if desired.\n              shouldAddOffset = getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min ? paddingObject[minProp] : paddingObject[maxProp]) - arrowDimensions[length] / 2 < 0;\n              alignmentOffset = shouldAddOffset ? center < min ? min - center : max - center : 0;\n              return _context2.abrupt(\"return\", (_ref4 = {}, _defineProperty(_ref4, axis, coords[axis] - alignmentOffset), _defineProperty(_ref4, \"data\", (_data = {}, _defineProperty(_data, axis, offset), _defineProperty(_data, \"centerOffset\", center - offset), _data)), _ref4));\n            case 29:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function fn(_x6) {\n        return _fn.apply(this, arguments);\n      }\n      return fn;\n    }()\n  };\n};\nvar sides = ['top', 'right', 'bottom', 'left'];\nvar allPlacements = /*#__PURE__*/sides.reduce(function (acc, side) {\n  return acc.concat(side, side + \"-start\", side + \"-end\");\n}, []);\nvar oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (side) {\n    return oppositeSideMap[side];\n  });\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  var alignment = getAlignment(placement);\n  var mainAxis = getMainAxisFromPlacement(placement);\n  var length = getLengthFromAxis(mainAxis);\n  var mainAlignmentSide = mainAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return {\n    main: mainAlignmentSide,\n    cross: getOppositePlacement(mainAlignmentSide)\n  };\n}\nvar oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, function (alignment) {\n    return oppositeAlignmentMap[alignment];\n  });\n}\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  var allowedPlacementsSortedByAlignment = alignment ? [].concat(_toConsumableArray(allowedPlacements.filter(function (placement) {\n    return getAlignment(placement) === alignment;\n  })), _toConsumableArray(allowedPlacements.filter(function (placement) {\n    return getAlignment(placement) !== alignment;\n  }))) : allowedPlacements.filter(function (placement) {\n    return getSide(placement) === placement;\n  });\n  return allowedPlacementsSortedByAlignment.filter(function (placement) {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Automatically chooses the `placement` which has the most space available.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nvar autoPlacement = function autoPlacement(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options: options,\n    fn: function () {\n      var _fn2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(middlewareArguments) {\n        var _middlewareData$autoP, _middlewareData$autoP2, _placementsSortedByLe, rects, middlewareData, placement, platform, elements, _options, alignment, _options$allowedPlace, allowedPlacements, _options$autoAlignmen, autoAlignment, detectOverflowOptions, placements, overflow, currentIndex, currentPlacement, _getAlignmentSides, main, cross, currentOverflows, allOverflows, nextPlacement, placementsSortedByLeastOverflow, placementThatFitsOnAllSides, resetPlacement;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              rects = middlewareArguments.rects, middlewareData = middlewareArguments.middlewareData, placement = middlewareArguments.placement, platform = middlewareArguments.platform, elements = middlewareArguments.elements;\n              _options = options, alignment = _options.alignment, _options$allowedPlace = _options.allowedPlacements, allowedPlacements = _options$allowedPlace === void 0 ? allPlacements : _options$allowedPlace, _options$autoAlignmen = _options.autoAlignment, autoAlignment = _options$autoAlignmen === void 0 ? true : _options$autoAlignmen, detectOverflowOptions = _objectWithoutProperties(_options, [\"alignment\", \"allowedPlacements\", \"autoAlignment\"]);\n              placements = alignment !== undefined || allowedPlacements === allPlacements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n              _context3.next = 5;\n              return detectOverflow(middlewareArguments, detectOverflowOptions);\n            case 5:\n              overflow = _context3.sent;\n              currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n              currentPlacement = placements[currentIndex];\n              if (!(currentPlacement == null)) {\n                _context3.next = 10;\n                break;\n              }\n              return _context3.abrupt(\"return\", {});\n            case 10:\n              _context3.t0 = getAlignmentSides;\n              _context3.t1 = currentPlacement;\n              _context3.t2 = rects;\n              _context3.next = 15;\n              return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);\n            case 15:\n              _context3.t3 = _context3.sent;\n              _getAlignmentSides = (0, _context3.t0)(_context3.t1, _context3.t2, _context3.t3);\n              main = _getAlignmentSides.main;\n              cross = _getAlignmentSides.cross;\n              if (!(placement !== currentPlacement)) {\n                _context3.next = 21;\n                break;\n              }\n              return _context3.abrupt(\"return\", {\n                reset: {\n                  placement: placements[0]\n                }\n              });\n            case 21:\n              currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];\n              allOverflows = [].concat(_toConsumableArray(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), [{\n                placement: currentPlacement,\n                overflows: currentOverflows\n              }]);\n              nextPlacement = placements[currentIndex + 1]; // There are more placements to check.\n              if (!nextPlacement) {\n                _context3.next = 26;\n                break;\n              }\n              return _context3.abrupt(\"return\", {\n                data: {\n                  index: currentIndex + 1,\n                  overflows: allOverflows\n                },\n                reset: {\n                  placement: nextPlacement\n                }\n              });\n            case 26:\n              placementsSortedByLeastOverflow = allOverflows.slice().sort(function (a, b) {\n                return a.overflows[0] - b.overflows[0];\n              });\n              placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find(function (_ref) {\n                var overflows = _ref.overflows;\n                return overflows.every(function (overflow) {\n                  return overflow <= 0;\n                });\n              })) == null ? void 0 : _placementsSortedByLe.placement;\n              resetPlacement = placementThatFitsOnAllSides || placementsSortedByLeastOverflow[0].placement;\n              if (!(resetPlacement !== placement)) {\n                _context3.next = 31;\n                break;\n              }\n              return _context3.abrupt(\"return\", {\n                data: {\n                  index: currentIndex + 1,\n                  overflows: allOverflows\n                },\n                reset: {\n                  placement: resetPlacement\n                }\n              });\n            case 31:\n              return _context3.abrupt(\"return\", {});\n            case 32:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      function fn(_x7) {\n        return _fn2.apply(this, arguments);\n      }\n      return fn;\n    }()\n  };\n};\nfunction getExpandedPlacements(placement) {\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getSideList(side, isStart, rtl) {\n  var lr = ['left', 'right'];\n  var rl = ['right', 'left'];\n  var tb = ['top', 'bottom'];\n  var bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  var alignment = getAlignment(placement);\n  var list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(function (side) {\n      return side + \"-\" + alignment;\n    });\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\n\n/**\n * Changes the placement of the floating element to one that will fit if the\n * initially specified `placement` does not.\n * @see https://floating-ui.com/docs/flip\n */\nvar flip = function flip(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options: options,\n    fn: function () {\n      var _fn3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(middlewareArguments) {\n        var _middlewareData$flip, placement, middlewareData, rects, initialPlacement, platform, elements, _options2, _options2$mainAxis, checkMainAxis, _options2$crossAxis, checkCrossAxis, specifiedFallbackPlacements, _options2$fallbackStr, fallbackStrategy, _options2$fallbackAxi, fallbackAxisSideDirection, _options2$flipAlignme, flipAlignment, detectOverflowOptions, side, isBasePlacement, rtl, fallbackPlacements, placements, overflow, overflows, overflowsData, _getAlignmentSides2, main, cross, _middlewareData$flip2, _overflowsData$find, nextIndex, nextPlacement, resetPlacement, _overflowsData$map$so, _placement;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              placement = middlewareArguments.placement, middlewareData = middlewareArguments.middlewareData, rects = middlewareArguments.rects, initialPlacement = middlewareArguments.initialPlacement, platform = middlewareArguments.platform, elements = middlewareArguments.elements;\n              _options2 = options, _options2$mainAxis = _options2.mainAxis, checkMainAxis = _options2$mainAxis === void 0 ? true : _options2$mainAxis, _options2$crossAxis = _options2.crossAxis, checkCrossAxis = _options2$crossAxis === void 0 ? true : _options2$crossAxis, specifiedFallbackPlacements = _options2.fallbackPlacements, _options2$fallbackStr = _options2.fallbackStrategy, fallbackStrategy = _options2$fallbackStr === void 0 ? 'bestFit' : _options2$fallbackStr, _options2$fallbackAxi = _options2.fallbackAxisSideDirection, fallbackAxisSideDirection = _options2$fallbackAxi === void 0 ? 'none' : _options2$fallbackAxi, _options2$flipAlignme = _options2.flipAlignment, flipAlignment = _options2$flipAlignme === void 0 ? true : _options2$flipAlignme, detectOverflowOptions = _objectWithoutProperties(_options2, [\"mainAxis\", \"crossAxis\", \"fallbackPlacements\", \"fallbackStrategy\", \"fallbackAxisSideDirection\", \"flipAlignment\"]);\n              side = getSide(placement);\n              isBasePlacement = getSide(initialPlacement) === initialPlacement;\n              _context4.next = 6;\n              return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);\n            case 6:\n              rtl = _context4.sent;\n              fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n              if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n                fallbackPlacements.push.apply(fallbackPlacements, _toConsumableArray(getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl)));\n              }\n              placements = [initialPlacement].concat(_toConsumableArray(fallbackPlacements));\n              _context4.next = 12;\n              return detectOverflow(middlewareArguments, detectOverflowOptions);\n            case 12:\n              overflow = _context4.sent;\n              overflows = [];\n              overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n              if (checkMainAxis) {\n                overflows.push(overflow[side]);\n              }\n              if (checkCrossAxis) {\n                _getAlignmentSides2 = getAlignmentSides(placement, rects, rtl), main = _getAlignmentSides2.main, cross = _getAlignmentSides2.cross;\n                overflows.push(overflow[main], overflow[cross]);\n              }\n              overflowsData = [].concat(_toConsumableArray(overflowsData), [{\n                placement: placement,\n                overflows: overflows\n              }]);\n\n              // One or more sides is overflowing.\n              if (overflows.every(function (side) {\n                return side <= 0;\n              })) {\n                _context4.next = 35;\n                break;\n              }\n              nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n              nextPlacement = placements[nextIndex];\n              if (!nextPlacement) {\n                _context4.next = 23;\n                break;\n              }\n              return _context4.abrupt(\"return\", {\n                data: {\n                  index: nextIndex,\n                  overflows: overflowsData\n                },\n                reset: {\n                  placement: nextPlacement\n                }\n              });\n            case 23:\n              // First, try to use the one that fits on mainAxis side of overflow.\n              resetPlacement = (_overflowsData$find = overflowsData.find(function (d) {\n                return d.overflows[0] <= 0;\n              })) == null ? void 0 : _overflowsData$find.placement; // Otherwise fallback.\n              if (resetPlacement) {\n                _context4.next = 33;\n                break;\n              }\n              _context4.t0 = fallbackStrategy;\n              _context4.next = _context4.t0 === 'bestFit' ? 28 : _context4.t0 === 'initialPlacement' ? 31 : 33;\n              break;\n            case 28:\n              _placement = (_overflowsData$map$so = overflowsData.map(function (d) {\n                return [d.placement, d.overflows.filter(function (overflow) {\n                  return overflow > 0;\n                }).reduce(function (acc, overflow) {\n                  return acc + overflow;\n                }, 0)];\n              }).sort(function (a, b) {\n                return a[1] - b[1];\n              })[0]) == null ? void 0 : _overflowsData$map$so[0];\n              if (_placement) {\n                resetPlacement = _placement;\n              }\n              return _context4.abrupt(\"break\", 33);\n            case 31:\n              resetPlacement = initialPlacement;\n              return _context4.abrupt(\"break\", 33);\n            case 33:\n              if (!(placement !== resetPlacement)) {\n                _context4.next = 35;\n                break;\n              }\n              return _context4.abrupt(\"return\", {\n                reset: {\n                  placement: resetPlacement\n                }\n              });\n            case 35:\n              return _context4.abrupt(\"return\", {});\n            case 36:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function fn(_x8) {\n        return _fn3.apply(this, arguments);\n      }\n      return fn;\n    }()\n  };\n};\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nvar hide = function hide(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options: options,\n    fn: function () {\n      var _fn4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(middlewareArguments) {\n        var _options3, _options3$strategy, strategy, detectOverflowOptions, rects, overflow, offsets, _overflow, _offsets;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _options3 = options, _options3$strategy = _options3.strategy, strategy = _options3$strategy === void 0 ? 'referenceHidden' : _options3$strategy, detectOverflowOptions = _objectWithoutProperties(_options3, [\"strategy\"]);\n              rects = middlewareArguments.rects;\n              _context5.t0 = strategy;\n              _context5.next = _context5.t0 === 'referenceHidden' ? 5 : _context5.t0 === 'escaped' ? 10 : 15;\n              break;\n            case 5:\n              _context5.next = 7;\n              return detectOverflow(middlewareArguments, _objectSpread({}, detectOverflowOptions, {\n                elementContext: 'reference'\n              }));\n            case 7:\n              overflow = _context5.sent;\n              offsets = getSideOffsets(overflow, rects.reference);\n              return _context5.abrupt(\"return\", {\n                data: {\n                  referenceHiddenOffsets: offsets,\n                  referenceHidden: isAnySideFullyClipped(offsets)\n                }\n              });\n            case 10:\n              _context5.next = 12;\n              return detectOverflow(middlewareArguments, _objectSpread({}, detectOverflowOptions, {\n                altBoundary: true\n              }));\n            case 12:\n              _overflow = _context5.sent;\n              _offsets = getSideOffsets(_overflow, rects.floating);\n              return _context5.abrupt(\"return\", {\n                data: {\n                  escapedOffsets: _offsets,\n                  escaped: isAnySideFullyClipped(_offsets)\n                }\n              });\n            case 15:\n              return _context5.abrupt(\"return\", {});\n            case 16:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }));\n      function fn(_x9) {\n        return _fn4.apply(this, arguments);\n      }\n      return fn;\n    }()\n  };\n};\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nvar inline = function inline(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options: options,\n    fn: function () {\n      var _fn5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(middlewareArguments) {\n        var placement, elements, rects, platform, strategy, _options4, _options4$padding, padding, x, y, fallback, clientRects, paddingObject, getBoundingClientRect, resetRects;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              getBoundingClientRect = function _getBoundingClientRec() {\n                // There are two rects and they are disjoined.\n                if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                  // Find the first rect in which the point is fully inside.\n                  return clientRects.find(function (rect) {\n                    return x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom;\n                  }) || fallback;\n                }\n\n                // There are 2 or more connected rects.\n                if (clientRects.length >= 2) {\n                  if (getMainAxisFromPlacement(placement) === 'x') {\n                    var firstRect = clientRects[0];\n                    var lastRect = clientRects[clientRects.length - 1];\n                    var isTop = getSide(placement) === 'top';\n                    var _top = firstRect.top;\n                    var _bottom = lastRect.bottom;\n                    var _left = isTop ? firstRect.left : lastRect.left;\n                    var _right = isTop ? firstRect.right : lastRect.right;\n                    var _width = _right - _left;\n                    var _height = _bottom - _top;\n                    return {\n                      top: _top,\n                      bottom: _bottom,\n                      left: _left,\n                      right: _right,\n                      width: _width,\n                      height: _height,\n                      x: _left,\n                      y: _top\n                    };\n                  }\n                  var isLeftSide = getSide(placement) === 'left';\n                  var maxRight = max.apply(void 0, _toConsumableArray(clientRects.map(function (rect) {\n                    return rect.right;\n                  })));\n                  var minLeft = min.apply(void 0, _toConsumableArray(clientRects.map(function (rect) {\n                    return rect.left;\n                  })));\n                  var measureRects = clientRects.filter(function (rect) {\n                    return isLeftSide ? rect.left === minLeft : rect.right === maxRight;\n                  });\n                  var top = measureRects[0].top;\n                  var bottom = measureRects[measureRects.length - 1].bottom;\n                  var left = minLeft;\n                  var right = maxRight;\n                  var width = right - left;\n                  var height = bottom - top;\n                  return {\n                    top: top,\n                    bottom: bottom,\n                    left: left,\n                    right: right,\n                    width: width,\n                    height: height,\n                    x: left,\n                    y: top\n                  };\n                }\n                return fallback;\n              };\n              placement = middlewareArguments.placement, elements = middlewareArguments.elements, rects = middlewareArguments.rects, platform = middlewareArguments.platform, strategy = middlewareArguments.strategy; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n              // ClientRect's bounds, despite the event listener being triggered. A\n              // padding of 2 seems to handle this issue.\n              _options4 = options, _options4$padding = _options4.padding, padding = _options4$padding === void 0 ? 2 : _options4$padding, x = _options4.x, y = _options4.y;\n              _context6.t0 = rectToClientRect;\n              if (!platform.convertOffsetParentRelativeRectToViewportRelativeRect) {\n                _context6.next = 17;\n                break;\n              }\n              _context6.t2 = platform;\n              _context6.t3 = rects.reference;\n              _context6.next = 9;\n              return platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating);\n            case 9:\n              _context6.t4 = _context6.sent;\n              _context6.t5 = strategy;\n              _context6.t6 = {\n                rect: _context6.t3,\n                offsetParent: _context6.t4,\n                strategy: _context6.t5\n              };\n              _context6.next = 14;\n              return _context6.t2.convertOffsetParentRelativeRectToViewportRelativeRect.call(_context6.t2, _context6.t6);\n            case 14:\n              _context6.t1 = _context6.sent;\n              _context6.next = 18;\n              break;\n            case 17:\n              _context6.t1 = rects.reference;\n            case 18:\n              _context6.t7 = _context6.t1;\n              fallback = (0, _context6.t0)(_context6.t7);\n              _context6.next = 22;\n              return platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference);\n            case 22:\n              _context6.t8 = _context6.sent;\n              if (_context6.t8) {\n                _context6.next = 25;\n                break;\n              }\n              _context6.t8 = [];\n            case 25:\n              clientRects = _context6.t8;\n              paddingObject = getSideObjectFromPadding(padding);\n              _context6.next = 29;\n              return platform.getElementRects({\n                reference: {\n                  getBoundingClientRect: getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy: strategy\n              });\n            case 29:\n              resetRects = _context6.sent;\n              if (!(rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height)) {\n                _context6.next = 32;\n                break;\n              }\n              return _context6.abrupt(\"return\", {\n                reset: {\n                  rects: resetRects\n                }\n              });\n            case 32:\n              return _context6.abrupt(\"return\", {});\n            case 33:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6);\n      }));\n      function fn(_x10) {\n        return _fn5.apply(this, arguments);\n      }\n      return fn;\n    }()\n  };\n};\nfunction convertValueToCoords(_x11, _x12) {\n  return _convertValueToCoords.apply(this, arguments);\n}\n/**\n * Displaces the floating element from its reference element.\n * @see https://floating-ui.com/docs/offset\n */\nfunction _convertValueToCoords() {\n  _convertValueToCoords = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(middlewareArguments, value) {\n    var placement, platform, elements, rtl, side, alignment, isVertical, mainAxisMulti, crossAxisMulti, rawValue, _ref6, mainAxis, crossAxis, alignmentAxis;\n    return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n      while (1) switch (_context11.prev = _context11.next) {\n        case 0:\n          placement = middlewareArguments.placement, platform = middlewareArguments.platform, elements = middlewareArguments.elements;\n          _context11.next = 3;\n          return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);\n        case 3:\n          rtl = _context11.sent;\n          side = getSide(placement);\n          alignment = getAlignment(placement);\n          isVertical = getMainAxisFromPlacement(placement) === 'x';\n          mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n          crossAxisMulti = rtl && isVertical ? -1 : 1;\n          rawValue = typeof value === 'function' ? value(middlewareArguments) : value; // eslint-disable-next-line prefer-const\n          _ref6 = typeof rawValue === 'number' ? {\n            mainAxis: rawValue,\n            crossAxis: 0,\n            alignmentAxis: null\n          } : _objectSpread({\n            mainAxis: 0,\n            crossAxis: 0,\n            alignmentAxis: null\n          }, rawValue), mainAxis = _ref6.mainAxis, crossAxis = _ref6.crossAxis, alignmentAxis = _ref6.alignmentAxis;\n          if (alignment && typeof alignmentAxis === 'number') {\n            crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n          }\n          return _context11.abrupt(\"return\", isVertical ? {\n            x: crossAxis * crossAxisMulti,\n            y: mainAxis * mainAxisMulti\n          } : {\n            x: mainAxis * mainAxisMulti,\n            y: crossAxis * crossAxisMulti\n          });\n        case 13:\n        case \"end\":\n          return _context11.stop();\n      }\n    }, _callee11);\n  }));\n  return _convertValueToCoords.apply(this, arguments);\n}\nvar offset = function offset(value) {\n  if (value === void 0) {\n    value = 0;\n  }\n  return {\n    name: 'offset',\n    options: value,\n    fn: function () {\n      var _fn6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(middlewareArguments) {\n        var x, y, diffCoords;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              x = middlewareArguments.x, y = middlewareArguments.y;\n              _context7.next = 3;\n              return convertValueToCoords(middlewareArguments, value);\n            case 3:\n              diffCoords = _context7.sent;\n              return _context7.abrupt(\"return\", {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: diffCoords\n              });\n            case 5:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7);\n      }));\n      function fn(_x13) {\n        return _fn6.apply(this, arguments);\n      }\n      return fn;\n    }()\n  };\n};\nfunction getCrossAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n\n/**\n * Shifts the floating element in order to keep it in view when it will overflow\n * a clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nvar shift = function shift(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options: options,\n    fn: function () {\n      var _fn7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(middlewareArguments) {\n        var _objectSpread3;\n        var x, y, placement, _options5, _options5$mainAxis, checkMainAxis, _options5$crossAxis, checkCrossAxis, _options5$limiter, limiter, detectOverflowOptions, coords, overflow, mainAxis, crossAxis, mainAxisCoord, crossAxisCoord, minSide, maxSide, _min, _max, _minSide, _maxSide, _min2, _max2, limitedCoords;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              x = middlewareArguments.x, y = middlewareArguments.y, placement = middlewareArguments.placement;\n              _options5 = options, _options5$mainAxis = _options5.mainAxis, checkMainAxis = _options5$mainAxis === void 0 ? true : _options5$mainAxis, _options5$crossAxis = _options5.crossAxis, checkCrossAxis = _options5$crossAxis === void 0 ? false : _options5$crossAxis, _options5$limiter = _options5.limiter, limiter = _options5$limiter === void 0 ? {\n                fn: function fn(_ref) {\n                  var x = _ref.x,\n                    y = _ref.y;\n                  return {\n                    x: x,\n                    y: y\n                  };\n                }\n              } : _options5$limiter, detectOverflowOptions = _objectWithoutProperties(_options5, [\"mainAxis\", \"crossAxis\", \"limiter\"]);\n              coords = {\n                x: x,\n                y: y\n              };\n              _context8.next = 5;\n              return detectOverflow(middlewareArguments, detectOverflowOptions);\n            case 5:\n              overflow = _context8.sent;\n              mainAxis = getMainAxisFromPlacement(getSide(placement));\n              crossAxis = getCrossAxis(mainAxis);\n              mainAxisCoord = coords[mainAxis];\n              crossAxisCoord = coords[crossAxis];\n              if (checkMainAxis) {\n                minSide = mainAxis === 'y' ? 'top' : 'left';\n                maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n                _min = mainAxisCoord + overflow[minSide];\n                _max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = within(_min, mainAxisCoord, _max);\n              }\n              if (checkCrossAxis) {\n                _minSide = crossAxis === 'y' ? 'top' : 'left';\n                _maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n                _min2 = crossAxisCoord + overflow[_minSide];\n                _max2 = crossAxisCoord - overflow[_maxSide];\n                crossAxisCoord = within(_min2, crossAxisCoord, _max2);\n              }\n              limitedCoords = limiter.fn(_objectSpread({}, middlewareArguments, (_objectSpread3 = {}, _defineProperty(_objectSpread3, mainAxis, mainAxisCoord), _defineProperty(_objectSpread3, crossAxis, crossAxisCoord), _objectSpread3)));\n              return _context8.abrupt(\"return\", _objectSpread({}, limitedCoords, {\n                data: {\n                  x: limitedCoords.x - x,\n                  y: limitedCoords.y - y\n                }\n              }));\n            case 14:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8);\n      }));\n      function fn(_x14) {\n        return _fn7.apply(this, arguments);\n      }\n      return fn;\n    }()\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nvar limitShift = function limitShift(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options: options,\n    fn: function fn(middlewareArguments) {\n      var _ref5;\n      var x = middlewareArguments.x,\n        y = middlewareArguments.y,\n        placement = middlewareArguments.placement,\n        rects = middlewareArguments.rects,\n        middlewareData = middlewareArguments.middlewareData;\n      var _options6 = options,\n        _options6$offset = _options6.offset,\n        offset = _options6$offset === void 0 ? 0 : _options6$offset,\n        _options6$mainAxis = _options6.mainAxis,\n        checkMainAxis = _options6$mainAxis === void 0 ? true : _options6$mainAxis,\n        _options6$crossAxis = _options6.crossAxis,\n        checkCrossAxis = _options6$crossAxis === void 0 ? true : _options6$crossAxis;\n      var coords = {\n        x: x,\n        y: y\n      };\n      var mainAxis = getMainAxisFromPlacement(placement);\n      var crossAxis = getCrossAxis(mainAxis);\n      var mainAxisCoord = coords[mainAxis];\n      var crossAxisCoord = coords[crossAxis];\n      var rawOffset = typeof offset === 'function' ? offset(middlewareArguments) : offset;\n      var computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : _objectSpread({\n        mainAxis: 0,\n        crossAxis: 0\n      }, rawOffset);\n      if (checkMainAxis) {\n        var len = mainAxis === 'y' ? 'height' : 'width';\n        var limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        var limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        var _len = mainAxis === 'y' ? 'width' : 'height';\n        var isOriginSide = ['top', 'left'].includes(getSide(placement));\n        var _limitMin = rects.reference[crossAxis] - rects.floating[_len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        var _limitMax = rects.reference[crossAxis] + rects.reference[_len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < _limitMin) {\n          crossAxisCoord = _limitMin;\n        } else if (crossAxisCoord > _limitMax) {\n          crossAxisCoord = _limitMax;\n        }\n      }\n      return _ref5 = {}, _defineProperty(_ref5, mainAxis, mainAxisCoord), _defineProperty(_ref5, crossAxis, crossAxisCoord), _ref5;\n    }\n  };\n};\n\n/**\n * Provides data to change the size of the floating element. For instance,\n * prevent it from overflowing its clipping boundary or match the width of the\n * reference element.\n * @see https://floating-ui.com/docs/size\n */\nvar size = function size(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options: options,\n    fn: function () {\n      var _fn8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(middlewareArguments) {\n        var placement, rects, platform, elements, _options7, _options7$apply, apply, detectOverflowOptions, overflow, side, alignment, heightSide, widthSide, xMin, xMax, yMin, yMax, dimensions, nextDimensions;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              placement = middlewareArguments.placement, rects = middlewareArguments.rects, platform = middlewareArguments.platform, elements = middlewareArguments.elements;\n              _options7 = options, _options7$apply = _options7.apply, apply = _options7$apply === void 0 ? function () {} : _options7$apply, detectOverflowOptions = _objectWithoutProperties(_options7, [\"apply\"]);\n              _context9.next = 4;\n              return detectOverflow(middlewareArguments, detectOverflowOptions);\n            case 4:\n              overflow = _context9.sent;\n              side = getSide(placement);\n              alignment = getAlignment(placement);\n              if (!(side === 'top' || side === 'bottom')) {\n                _context9.next = 26;\n                break;\n              }\n              heightSide = side;\n              _context9.t0 = alignment;\n              _context9.next = 12;\n              return platform.isRTL == null ? void 0 : platform.isRTL(elements.floating);\n            case 12:\n              if (!_context9.sent) {\n                _context9.next = 16;\n                break;\n              }\n              _context9.t1 = 'start';\n              _context9.next = 17;\n              break;\n            case 16:\n              _context9.t1 = 'end';\n            case 17:\n              _context9.t2 = _context9.t1;\n              if (!(_context9.t0 === _context9.t2)) {\n                _context9.next = 22;\n                break;\n              }\n              _context9.t3 = 'left';\n              _context9.next = 23;\n              break;\n            case 22:\n              _context9.t3 = 'right';\n            case 23:\n              widthSide = _context9.t3;\n              _context9.next = 28;\n              break;\n            case 26:\n              widthSide = side;\n              heightSide = alignment === 'end' ? 'top' : 'bottom';\n            case 28:\n              xMin = max(overflow.left, 0);\n              xMax = max(overflow.right, 0);\n              yMin = max(overflow.top, 0);\n              yMax = max(overflow.bottom, 0);\n              dimensions = {\n                availableHeight: rects.floating.height - (['left', 'right'].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),\n                availableWidth: rects.floating.width - (['top', 'bottom'].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])\n              };\n              _context9.next = 35;\n              return apply(_objectSpread({}, middlewareArguments, dimensions));\n            case 35:\n              _context9.next = 37;\n              return platform.getDimensions(elements.floating);\n            case 37:\n              nextDimensions = _context9.sent;\n              if (!(rects.floating.width !== nextDimensions.width || rects.floating.height !== nextDimensions.height)) {\n                _context9.next = 40;\n                break;\n              }\n              return _context9.abrupt(\"return\", {\n                reset: {\n                  rects: true\n                }\n              });\n            case 40:\n              return _context9.abrupt(\"return\", {});\n            case 41:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9);\n      }));\n      function fn(_x15) {\n        return _fn8.apply(this, arguments);\n      }\n      return fn;\n    }()\n  };\n};\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, rectToClientRect, shift, size };","map":null,"metadata":{},"sourceType":"module"}